<!DOCTYPE html>
<html lang="en">
  <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />

    <title>grtnr.com</title>

    <meta charset="utf-8" />
    <link rel="stylesheet" href="../theme/css/poole.css"/>
    <link rel="stylesheet" href="../theme/css/syntax.css"/>
    <link rel="stylesheet" href="../theme/css/lanyon.css"/>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
    <link rel="stylesheet" href="../theme/css/styles.css"/>




  </head>

  <body>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">
<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="profile">
      <img src="../theme/img/profile.png"/>
    </div>
  </div>

  <nav class="sidebar-nav">
  <a class="sidebar-nav-item" href="../">All</a>

      <a class="sidebar-nav-item" href="../category/misc.html">misc</a>

  <a class="sidebar-nav-item" href="https://getpelican.com/">Pelican</a>
  <a class="sidebar-nav-item" href="https://www.python.org/">Python.org</a>
  <a class="sidebar-nav-item" href="https://palletsprojects.com/p/jinja/">Jinja2</a>
  <a class="sidebar-nav-item" href="#">You can modify those links in your config file</a>
  </nav>

  <div class="sidebar-item">
    <p>
    <a href="https://twitter.com/tillg">&copy; @tillg</a> 2017
    </p>
    <p class="tiny-note">
      <a class="muted" href="https://github.com/thomaswilley/pelicanyan">pelicanyan v0.1</a>
    </p>
  </div>
</div>    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="../" title="Home">grtnr.com</a>
          </h3>
        </div>
      </div>

      <div class="container content">
<div class="posts">
<div class="post">
    <h1 class="post-title">
      Digital&nbsp;Garden
    </h1>
    <span class="post-date">April 18, 2025</span>

    <p><img alt="Digital garden" src="digital-garden.jpg"></p>
<ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#technology-and-architecture">Technology and&nbsp;Architecture</a></li>
<li><a href="#chatgpt-building-a-python-powered-digital-garden-stack--architecture">ChatGPT: Building a Python-Powered Digital Garden: Stack \&amp; Architecture</a><ul>
<li><a href="#static-site-generator--content-organization">Static Site Generator \&amp; Content&nbsp;Organization</a></li>
<li><a href="#markdown-editing--local-preview">Markdown Editing \&amp; Local&nbsp;Preview</a></li>
<li><a href="#wiki-style-internal-linking--backlinks">Wiki-Style Internal Linking \&amp;&nbsp;Backlinks</a></li>
<li><a href="#custom-content-types--templates">Custom Content Types \&amp;&nbsp;Templates</a></li>
<li><a href="#beautiful-theming-ghost-inspired-design">Beautiful Theming (Ghost-Inspired&nbsp;Design)</a></li>
<li><a href="#multi-language-support--ai-translations">Multi-Language Support \&amp; <span class="caps">AI</span>&nbsp;Translations</a></li>
<li><a href="#content-access-control-roles--authentication">Content Access Control (Roles \&amp;&nbsp;Authentication)</a></li>
<li><a href="#tags-indexes-and-navigation-pages">Tags, Indexes, and Navigation&nbsp;Pages</a></li>
<li><a href="#build-pipeline--link-validation">Build Pipeline \&amp; Link&nbsp;Validation</a></li>
<li><a href="#summary-of-the-recommended-stack">Summary of the Recommended&nbsp;Stack</a></li>
</ul>
</li>
<li><a href="#follow-up-questions">Follow up questions</a><ul>
<li><a href="#changing-the-structure">Changing the&nbsp;structure</a></li>
<li><a href="#articles-or-pages">Articles or&nbsp;Pages?</a></li>
</ul>
</li>
<li><a href="#playing-around">Playing&nbsp;around</a></li>
</ul>
<p>I read about Digital Gardens on <a href="https://www.heise.de/hintergrund/Nerd-Trend-Digitaler-Garten-Die-eigene-Website-als-persoenliches-Wissensarchiv-10344169.html">heise (in German)</a> and really liked the idea. The key differences to my current blog that I thought of&nbsp;are</p>
<ul>
<li>The idea of writing down ideas and starting articles right away - and having them in the garden immediatly. That&#8217;s a big digfference to the attidude of &#8220;I need to finish the article before I publish&nbsp;it&#8221;.</li>
<li>The idea of linking to other articles and creating a network of articles. That&#8217;s something I can already do in my blog, but the process is delicate: If I rename or move an article around, the links to it are broken. Also the idea of backlinks is&nbsp;striking.</li>
<li>Putting the topics more to the front rather than the date: My blog is primarely structured and presented by date. Having the topic(s) more as navigation structure seems compelling. Of course I would still l√∂eave the date of creation, as well as the date of the last&nbsp;modification.</li>
</ul>
<h1>Requirements</h1>
<p>As usual I tend to start by looking at the technical side üòÄ. So I jotted down my requirements and asked ChatGPT for&nbsp;help.</p>
<p>My requirements for a digital garden&nbsp;system:</p>
<ul>
<li>Articles are based on markdown&nbsp;files.</li>
<li>Built as static generated&nbsp;website.</li>
<li>One article in one directory together with its resources: pictures, PDFs, other files. This way local rendering per article makes sense, very helpful while editing. I would edit the articles with VScode or another editor that has markdown&nbsp;support.</li>
<li>Articles (i.e. their directories) can be in a directory tree structure. Their directory structure describes the category. For&nbsp;example/tech/dev/data_science</li>
<li>Written in Python, so I can tinker&nbsp;around.</li>
<li>Build pipeline can be completed: a stage to check internal&nbsp;links.</li>
<li>Internal links as <em>[ [links] ]</em>. And show backlinks in linked&nbsp;articles.</li>
<li>I want to easily create specific article types with special structure, fields, rendering. Examples are <span class="caps">RECIPE</span>, <span class="caps">PLACE</span> or <span class="caps">LOCATION</span>, <span class="caps">TRIP</span> <span class="caps">ADVENTURE</span>,&nbsp;‚Ä¶</li>
<li>Beautiful site! Not like a messy nerdy garden! Take inspiration from beautiful blogs like&nbsp;ghost.</li>
<li>Multilingual, with languages filled up by <span class="caps">AI</span> if not provided by&nbsp;author.</li>
<li>Different access rights: some content is public, other for family <span class="amp">&amp;</span> friends or other user&nbsp;groups.</li>
<li>Access roles, for example: articles that are unpublished can only be seen by users with role <span class="caps">EDITOR</span>.</li>
<li>Allow multiple index pages: tags, historical index (maybe also per tag), most read, most starred‚Ä¶ Index pages can be generated but also hand crafted. Specifically the home&nbsp;page.</li>
</ul>
<h1>Technology and&nbsp;Architecture</h1>
<p><a href="https://chatgpt.com/share/68026bb5-d040-8009-9f79-ec0fd35880f4">This is what ChatGPT produced</a> (I thionk it&#8217;s really good, so I paste it all&nbsp;here):</p>
<p>Great. I‚Äôll explore the best Python-based static site generators and architecture for building a beautifully styled, markdown-driven digital garden with support for access control, internal link checking, multilingual support, and article-type customization. I‚Äôll also ensure the system supports your preferred local editing flow, generates plain <span class="caps">HTML</span>, and works well with GitHub&nbsp;Pages.</p>
<p>I‚Äôll get back to you with a recommended stack, architecture diagram, and suggestions on how to implement your requirements&nbsp;smoothly.</p>
<p><em>Researched for 11m 16s * 23&nbsp;sources</em></p>
<h1>ChatGPT: Building a Python-Powered Digital Garden: Stack <span class="amp">&amp;</span>&nbsp;Architecture</h1>
<h2>Static Site Generator <span class="amp">&amp;</span> Content&nbsp;Organization</h2>
<p>For a <strong>Python-based static site generator</strong>, <strong>Pelican</strong> is an excellent choice. Pelican is actively maintained and well-documented, supporting Markdown content and multi-language publishing out-of-the-box (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). It generates a plain <span class="caps">HTML</span> site (no need for React/Vue) and has a rich plugin ecosystem for extending functionality (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). </p>
<p><strong>Content Structure:</strong> Organize the digital garden‚Äôs content in a logical directory hierarchy under&nbsp;Pelican‚Äôs <code>content/</code> folder. Each article lives in its own subdirectory alongside its assets. For&nbsp;example: </p>
<div class="highlight"><pre><span></span><code>content/
‚îú‚îÄ‚îÄ tech/
‚îÇ   ‚îî‚îÄ‚îÄ dev/
‚îÇ        ‚îî‚îÄ‚îÄ data_science/
‚îÇ             ‚îî‚îÄ‚îÄ my-article/ 
‚îÇ                  ‚îú‚îÄ‚îÄ index.md        # Article in Markdown
‚îÇ                  ‚îú‚îÄ‚îÄ figure1.png     # Images/PDFs related to article
‚îÇ                  ‚îî‚îÄ‚îÄ data.pdf
‚îî‚îÄ‚îÄ travel/
    ‚îî‚îÄ‚îÄ trip-to-paris/
         ‚îú‚îÄ‚îÄ index.md
         ‚îî‚îÄ‚îÄ eiffel.jpg
</code></pre></div>

<p>In this layout, every article&nbsp;(<code>index.md</code>) is grouped with its media. Pelican can handle ‚Äúpage bundles‚Äù like this by treating those subfolders as both content and static paths. We configure Pelican‚Äôs settings to include each folder&nbsp;in <code>ARTICLE_PATHS</code> and <code>STATIC_PATHS</code> so that markdown files are processed and assets are copied through to output (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Starting%20with%20Pelican%203,directory%20reserved%20for%20static%20files">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=generated%20site,in%20earlier%20versions%20of%20Pelican">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). Pelican‚Äôs <strong>attach syntax</strong> allows linking to local files easily: in Markdown,&nbsp;use <code>{attach}</code> to reference files in the same folder. For&nbsp;example: <code>![Figure]({attach}figure1.png)</code> in <code>my-article/index.md</code> will copy <em>figure1.png</em> into the article‚Äôs output directory and link to it (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Starting%20with%20Pelican%203,sibling%20of%20the%20linking%20document">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Title%3A%20Test%20Post%20Category%3A%20test,31">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). This keeps images/PDFs co-located with their article and ensures links aren‚Äôt broken after the static build (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=output%20%E2%94%94%E2%94%80%E2%94%80%202014%20%E2%94%9C%E2%94%80%E2%94%80%20archive,post.html">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). </p>
<p>Pelican also supports using folder names as categories automatically. By default, the immediate parent folder becomes the category (e.g. ‚Äúdata_science‚Äù in the path above) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Note%20that%2C%20aside%20from%20the,W3C%E2%80%99s%20suggested%20subset%20ISO%208601">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>). We can preserve deeper nesting in URLs by customizing the save path. For instance,&nbsp;setting <code>ARTICLE_SAVE_AS = '{category}/{slug}/index.html'</code> and&nbsp;similar <code>ARTICLE_URL</code> will output each post as&nbsp;an <code>index.html</code> inside a folder matching its category/slug. This yields clean URLs&nbsp;like <code>/tech/dev/data_science/my-article/</code> reflecting the directory structure.&nbsp;(Pelican‚Äôs <code>USE_FOLDER_AS_CATEGORY=True</code> by default uses the lowest folder as category; for multi-level taxonomy, one can either combine the path into one category or treat top folders as sections and use tags for&nbsp;sub-classification.) </p>
<h2>Markdown Editing <span class="amp">&amp;</span> Local&nbsp;Preview</h2>
<p>All articles are written in plain <strong>Markdown</strong> (with <span class="caps">YAML</span>/<span class="caps">TOML</span> front matter for metadata) so you can comfortably author content in <span class="caps">VS</span> Code or any editor. Each Markdown file begins with metadata like title, date, tags, etc. Pelican only requires a title (it can derive others if needed) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Note%20that%2C%20aside%20from%20the,W3C%E2%80%99s%20suggested%20subset%20ISO%208601">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>), but we‚Äôll use metadata extensively for custom behavior (more on this later). A sample front matter for an article might&nbsp;be: </p>
<div class="highlight"><pre><span></span><code>Title: My Data Science Journey  
Date: 2025-04-10  
Category: data_science  
Tags: python, analytics  
Slug: my-data-science-journey  
Status: published  
</code></pre></div>

<p><strong>Local Preview:</strong> To enable per-article preview while editing, use Pelican‚Äôs built-in development server. Pelican‚Äôs <span class="caps">CLI</span>/Makefile supports an auto-reload server&nbsp;(e.g. <code>make devserver</code> or <code>pelican --autoreload --listen</code>) that watches for file changes and rebuilds as you write. This way, you can navigate&nbsp;to <code>http://localhost:8000/tech/dev/data_science/my-article/</code> and see the rendered <span class="caps">HTML</span> update on each save. Because Pelican does selective output writing and caching, rebuilds are fast even for large sites (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). This gives a near real-time preview of the article in the context of the actual theme/template. For quick iteration on a single page, Pelican‚Äôs incremental build will detect only <em>my-article</em> has changed and regenerate just that page, making the feedback loop quick. <span class="caps">VS</span> Code can also preview Markdown, but using Pelican‚Äôs server ensures the content is seen with the final site‚Äôs styling and&nbsp;layout. </p>
<h2>Wiki-Style Internal Linking <span class="amp">&amp;</span>&nbsp;Backlinks</h2>
<p>To interconnect notes in wiki fashion, we enable <strong>[[Wiki-Style]] linking</strong> in Markdown. Pelican has a community plugin called <strong>Wikilinks</strong> that automatically&nbsp;converts <code>[[Page Name]]</code> syntax into proper hyperlinks between pages (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>). For example,&nbsp;writing <code>We build on ideas from [[My Data Science Journey]]</code> in another article will link to the ‚ÄúMy Data Science Journey‚Äù page (resolving to its slug or filename). The Wikilinks plugin supports optional display text&nbsp;(e.g. <code>[[Page Name|custom text]]</code>) (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>). Under the hood, it scans&nbsp;for <code>[[...]]</code> patterns after markdown processing and replaces them&nbsp;with <code>&lt;a&gt;</code> links to the target page‚Äôs <span class="caps">URL</span> (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=In%20basic%20usage%2C%20this%20allow,is%20finished">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>). This makes cross-referencing content as easy as in tools like Obsidian or Roam. (We will enforce unique filenames for notes to avoid ambiguous links (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Known%20Issues">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>).) </p>
<p><strong>Backlinks:</strong> To achieve bi-directional linking (seeing what links back to a page), we can create a custom Pelican plugin or utilize the site‚Äôs metadata. During the build, we can collect all the wiki link references: e.g. maintain a dictionary mapping each target page to a list of pages that mentioned it. Then extend Pelican‚Äôs article context to include a ‚Äúbacklinks‚Äù list for each article. Finally, in the article template, if backlinks exist, render a section ‚Äú<strong>Linked from:</strong> ‚Ä¶‚Äù listing those referring pages. This requires a custom plugin that hooks into Pelican‚Äôs generation phase (using signals&nbsp;like <code>article_generator_finalized</code>) to gather links and inject the data. The effort is manageable given Pelican‚Äôs plugin <span class="caps">API</span> (Python hooks), and ensures every page ends with a list of other notes that link to it, reinforcing the wiki-like navigation. If writing a plugin from scratch, we‚Äôd parse each article‚Äôs <span class="caps">HTML</span> (or use the internal link map from the Wikilinks plugin) to identify&nbsp;outgoing <code>href</code>s pointing inside the site, then invert that&nbsp;mapping. </p>
<p>Pelican‚Äôs standard linking syntax&nbsp;(<code>{filename}target.md</code>) could also be used for internal links (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=the%20other%20content%20will%20be,placed%20after%20site%20generation">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=,filename%7D%2Farticle2.md">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>), but the wiki-style is more intuitive for a digital garden workflow. With the Wikilinks plugin and a backlinks plugin, the site will have <strong>fully connected pages</strong> with automatic&nbsp;references. </p>
<h2>Custom Content Types <span class="amp">&amp;</span>&nbsp;Templates</h2>
<p>One strength of Pelican is its flexible metadata and templating, which we leverage to define <strong>custom article types</strong>&nbsp;like <code>RECIPE</code> or <code>TRIP</code>. All Markdown files can include arbitrary front-matter fields (as long as they don‚Äôt conflict with reserved keywords) (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=This%20is%20the%20content%20of,my%20super%20blog%20post">Writing content ‚Äî Pelican 4.7.2 documentation</a>) (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=,false">Writing content ‚Äî Pelican 4.7.2 documentation</a>). We define a metadata&nbsp;field <code>Type</code> (or use a tag/category) to denote the content type, and add any custom fields needed. For example, a recipe might&nbsp;have: </p>
<div class="highlight"><pre><span></span><code>Title: Chocolate Chip Cookies  
Date: 2025-03-01  
Type: recipe  
Servings: 4  
Prep_Time: 15 min  
Cook_Time: 10 min  
Ingredients: 
<span class="w">  </span><span class="k">-</span><span class="w"> </span>Flour 
<span class="w">  </span><span class="k">-</span><span class="w"> </span>Sugar 
<span class="w">  </span><span class="k">-</span><span class="w"> </span>Chocolate chips 
Steps: 
<span class="w">  </span><span class="k">1.</span> Preheat oven‚Ä¶  
<span class="w">  </span><span class="k">2.</span> Mix ingredients‚Ä¶  
Template: recipe  &lt;!-- use a custom Jinja template --&gt;
</code></pre></div>

<p>In this case, we&nbsp;set <code>Template: recipe</code> which tells Pelican to render this page&nbsp;with <code>recipe.html</code> instead of the default template (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=match%20at%20L131%20,to%20use%20for%20this%20article%2Fpage">Writing content ‚Äî Pelican 4.7.2 documentation</a>). We will create separate Jinja2 templates&nbsp;(e.g., <code>recipe.html</code>, <code>trip.html</code>) in the theme. These templates extend the base layout but present the content in a specialized way. For instance, <strong><code>recipe.html</code></strong> can format the Ingredients list as a checklist, show Prep/Cook time in a sidebar, etc., whereas <strong><code>trip.html</code></strong> might display location info, dates, and an image gallery differently. Pelican will pass all front-matter fields into the template context, so fields&nbsp;like <code>Ingredients</code> or <code>Location</code> become accessible variables. We can thus iterate&nbsp;over <code>recipe.ingredients</code> in Jinja to output an <span class="caps">HTML</span> list, for example. This approach gives us <strong>structured content</strong> without needing a database ‚Äì essentially a lightweight <span class="caps">CMS</span> defined via markdown&nbsp;metadata. </p>
<p>Pelican‚Äôs flexibility here means we can support any number of content types. If needed, we could also write a Pelican plugin to validate that required fields are present for each type (ensuring, say,&nbsp;every <code>Type: recipe</code> file has an Ingredients list) or even generate additional pages (e.g., an index of all recipes). But even without extra plugins, using Jinja templates keyed on a metadata flag is sufficient and keeps things&nbsp;simple. </p>
<h2>Beautiful Theming (Ghost-Inspired&nbsp;Design)</h2>
<p>We want the site to look modern and polished ‚Äì more like a blog or magazine than a raw wiki. Pelican supports theming with Jinja2 templates and static <span class="caps">CSS</span>, allowing full control over design (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). We can start from an existing <strong>Ghost-inspired theme</strong> for Pelican to save time. For example, the <em>Casper</em> theme (Ghost‚Äôs default) has been ported to Pelican as <strong>Casper2Pelican</strong> (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Casper2Pelican">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>), and others like <em>Nicholas</em> or <em>Ghastly</em> offer clean Ghost-like aesthetics. These themes feature modern typography, responsive layout, and support for cover images and author profiles. The Casper2Pelican <span class="caps">README</span> notes it‚Äôs based on Ghost‚Äôs default and even supports author bios, social sharing, and header images via metadata (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=,and%20share%20buttons%20on%20article">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>). Using such a theme (or a similar Pelican theme) gives us a head start with a <strong>beautiful design</strong> consistent with popular&nbsp;blogs. </p>
<p>We can customize the theme further to match our vision. This might include: 
- <strong>Header images</strong> for articles: e.g. using a metadata&nbsp;field <code>Image: path/to/cover.jpg</code> which the template uses as a banner at the top of a post (Casper2Pelican already checks&nbsp;an <code>image</code> field for header image (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=,and%20share%20buttons%20on%20article">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)). 
- <strong>Navigation and Home Page:</strong> We‚Äôll create a custom home page instead of a simple blog index. For instance, design a welcome page&nbsp;(<code>content/pages/home.md</code>) with an overview and featured posts. Using Pelican‚Äôs pages feature, we&nbsp;set <code>SAVE_AS = 'index.html'</code> for that page so it becomes the landing page. The normal blog index (listing latest notes) can be generated&nbsp;at <code>/archive/</code> or a different <span class="caps">URL</span>. 
- <strong><span class="caps">CSS</span> Framework:</strong> Optionally, incorporate a modern <span class="caps">CSS</span> framework or utility library (e.g. Tailwind or Bootstrap) to easily achieve a clean look for elements like tables, code blocks, callouts, etc., if the chosen theme doesn‚Äôt already handle it. Many Pelican themes use Bootstrap 4/5 or pure <span class="caps">CSS</span>. We should ensure the styling for wiki link references and backlinks section is cohesive (e.g., backlinks as a small italicized list at bottom). 
- <strong>Mobile-friendly design:</strong> The theme should be responsive; Ghost-based themes typically are. We‚Äôll verify that navigation (category lists, tag pages) collapses nicely on&nbsp;mobile. </p>
<p>By leveraging an existing theme and tweaking it, we meet the requirement of a <strong>‚Äúbeautiful design inspired by modern blogs‚Äù</strong>. Pelican‚Äôs theme system separates content from presentation, so we can iterate on the look independently. The end result won‚Äôt feel like a bare-bones dev wiki ‚Äì instead, it will have polished typography, spacing, and visuals similar to a Ghost blog (as evidenced by the Casper2Pelican screenshot and demo blogs (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Demo">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)). </p>
<h2>Multi-Language Support <span class="amp">&amp;</span> <span class="caps">AI</span>&nbsp;Translations</h2>
<p>The digital garden will be <strong>multilingual</strong>, serving content in (for example) English and Spanish. Pelican, with the <strong><code>i18n_subsites</code></strong> plugin, can generate a multi-language site where each language is a sub-site. We organize content by language ‚Äì&nbsp;e.g. <code>content/en/...</code> and <code>content/es/...</code> ‚Äì or include&nbsp;a <code>Lang</code> metadata on each file. Pelican‚Äôs multi-language support allows each article to have translated counterparts identified by the same slug and&nbsp;a <code>lang</code> code (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=,without%20extension">Writing content ‚Äî Pelican 4.7.2 documentation</a>). At build time, the i18n plugin produces separate output folders for each language (or language-specific paths) and can generate a language switcher. The Pelican docs highlight <em>‚Äúpublication of articles in multiple languages‚Äù</em> as a core feature (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>). In practice, you might&nbsp;have <code>my-article.en.md</code> and <code>my-article.es.md</code>. If a translation is missing, Pelican can default to the original or we can configure fallback&nbsp;behavior.</p>
<p><strong>Auto-fill with <span class="caps">AI</span>:</strong> To meet the requirement of filling untranslated content using <span class="caps">AI</span>, we introduce a <strong>translation pipeline step</strong>. This would run <em>before</em> or <em>during</em> the build. For any article that lacks a manual translation, a script can automatically generate one via an <span class="caps">AI</span> translation service. For example, we could use a translation <span class="caps">API</span> (like DeepL or Google Cloud Translate) or an <span class="caps">AI</span> model (like <span class="caps">GPT</span>-4) through their Python SDKs to translate English Markdown to Spanish Markdown. The build workflow could be:
1. Detect articles that exist in English but not in Spanish (perhaps by scanning&nbsp;the <code>content/en</code> vs <code>content/es</code> directories).
2. For each missing translation, call the <span class="caps">AI</span> <span class="caps">API</span> to produce a translated Markdown text. Preserve the front matter&nbsp;(with <code>lang: es</code> and a note that it‚Äôs auto-generated) and have the body translated. 
3. Save these generated files&nbsp;in <code>content/es/...</code> so that Pelican includes them in the site generation. Optionally mark them with a flag&nbsp;(e.g. <code>Translation: machine</code>) that the template can use to display a disclaimer banner like ‚Äúü§ñ This is an <span class="caps">AI</span>-translated version; it may contain&nbsp;errors.‚Äù </p>
<p>Because this process can be time-consuming or cost <span class="caps">API</span> usage, we‚Äôd integrate it as an optional step (only generate if the file isn‚Äôt already there, and possibly commit the result to the repo so it‚Äôs reused). This way, untranslated content is automatically populated, ensuring the Spanish site is never missing a page ‚Äì it will either have a human-written translation or an <span class="caps">AI</span>-provided&nbsp;one. </p>
<p>Pelican‚Äôs i18n plugin will link between language versions of each page (it adds link rel=&#8221;alternate&#8221; and allows template language switchers). We can thus have a language toggle on each page. Users will see a fully bilingual site, largely maintained by writing primarily in one language and letting <span class="caps">AI</span> assist with the&nbsp;other. </p>
<p>All tools here are Python-friendly: Pelican‚Äôs plugin is Python, and calling an <span class="caps">AI</span> translation (via requests or an <span class="caps">SDK</span>) is straightforward to script. This setup future-proofs the site ‚Äì content creators can focus on one language, and <span class="caps">AI</span> can help keep other languages&nbsp;up-to-date. </p>
<h2>Content Access Control (Roles <span class="amp">&amp;</span>&nbsp;Authentication)</h2>
<p>Even though the site is static, we need <strong>access roles</strong> for certain content (public vs friends/family vs private drafts). We can handle this by a combination of build-time filtering and client-side authentication using&nbsp;Auth0. </p>
<p><strong>Drafts <span class="amp">&amp;</span> Unlisted Posts:</strong> Pelican supports&nbsp;a <code>Status</code> metadata. If we mark an&nbsp;article <code>Status: draft</code>, Pelican will not publish it (by default (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=,without%20extension">Writing content ‚Äî Pelican 4.7.2 documentation</a>) (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=If%20your%20articles%20should%20be,include%20the%20status%20in%20the">Writing content ‚Äî Pelican 4.7.2 documentation</a>)„Äë, so drafts remain excluded from the generated site. For ‚Äúfriends/family‚Äù posts that are finished but should not be public, we can use&nbsp;Pelican‚Äôs <code>hidden</code> status (or simply exclude them from indexes).&nbsp;A <code>Status: hidden</code> post <em>is</em> generated as an <span class="caps">HTML</span> page but is omitted from feeds and listing (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=on%20the%20index%20page%20nor,any%20category%20or%20tag%20page">Writing content ‚Äî Pelican 4.7.2 documentation</a>)„Äë. This creates an <strong>unlisted page</strong> ‚Äì only accessible if you know the <span class="caps">URL</span>. We can distribute those URLs privately. This provides basic obscurity but not true&nbsp;security. </p>
<p>For stronger protection, we integrate <strong>Auth0 authentication</strong> into the static site. At build time, we decide which pages require login. For example, we might add a metadata&nbsp;flag <code>Visibility: friends</code> or <code>auth_required: true</code> for pages that should only be seen by certain users. The build process can then inject an Auth0 login gate into those pages. Concretely, we can create a Jinja template snippet that includes the Auth0 JavaScript <span class="caps">SDK</span> and a script to enforce login. Each protected page, when rendered, would contain something&nbsp;like: </p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;protected-content&quot;</span><span class="p">&gt;</span> ... full content ... <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;https://cdn.auth0.com/js/auth0-spa-js/1.XX/auth0-spa.min.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="w">  </span><span class="c1">// Initialize Auth0 client</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">auth0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">createAuth0Client</span><span class="p">({</span><span class="w"> </span><span class="nx">domain</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;YOUR_DOMAIN&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">client_id</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;YOUR_CLIENTID&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">cacheLocation</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;localstorage&#39;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">isAuthenticated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">auth0</span><span class="p">.</span><span class="nx">isAuthenticated</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">isAuthenticated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;protected-content&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;none&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Show a login button or auto-login:</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="nx">auth0</span><span class="p">.</span><span class="nx">loginWithRedirect</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;protected-content&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;block&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div>

<p>This is a sketch, but the idea is the page will require an Auth0 login before showing content. Auth0 will handle the login redirect and token management (the Auth0 <span class="caps">SPA</span> <span class="caps">SDK</span> is used as shown in Auth0‚Äôs Gatsby exampl (<a href="https://auth0.com/blog/securing-gatsby-with-auth0/#:~:text=How%20to%20Secure%20GatsbyJS%20Sites,management%20on%20a%20GatsbyJS">How to Secure GatsbyJS Sites with Auth0 for Authentication</a>) (<a href="https://auth0.com/blog/securing-gatsby-with-auth0/#:~:text=How%20to%20Secure%20GatsbyJS%20Sites,management%20on%20a%20GatsbyJS">How to Secure GatsbyJS Sites with Auth0 for Authentication</a>)„Äë). At build-time we embed the Auth0 credentials (domain, client <span class="caps">ID</span>) which are not sensitive. We do <strong>not</strong> include any secret keys in the static code. After login, the content div becomes&nbsp;visible. </p>
<p><strong>Role-Based Access:</strong> Auth0 supports role claims in token (<a href="https://auth0.com/docs/manage-users/access-control/configure-core-rbac/roles#:~:text=We%20provide%20various%20functions%20to,or%20the%20Auth0%20Management%20API">Manage Role-Based Access Control Roles - Auth0</a>)„Äë. If we want to distinguish ‚Äúfriends and family‚Äù vs ‚Äúeditors‚Äù, we can assign roles in Auth0 (e.g., a user role ‚Äúfamily‚Äù or an allowed email list). The front-end script can then query the user‚Äôs profile/claims after login and decide whether to show the page. For example, a page for ‚Äúfamily‚Äù could&nbsp;check <code>if(user.roles.includes('family')) { show content } else { hide and show "Access Denied" }</code>. This check is done client-side with the data from Auth0. While not foolproof (since the <span class="caps">HTML</span> is technically delivered), we could also choose not to even deploy certain files publicly. Another approach is to generate two versions of the site: one public (excluding private pages entirely) and one for authenticated use. However, since the requirement is static hosting on GitHub Pages (which doesn‚Äôt support server-side auth), using Auth0‚Äôs client-side gating is a practical solutio (<a href="https://community.auth0.com/t/protecting-static-website-using-auth0-but-using-existing-users/76359#:~:text=Hello,Auth0%20JavaScript%20SDK%20Quickstarts%3A%20Login">Protecting Static Website using Auth0 but using existing users - Auth0 Community</a>)„Äë. </p>
<p>In summary, public content will be generated normally and listed on the site. Private content will either be hidden from listings or not present at all in the public build. If hidden but present, they will have Auth0 code embedded to ensure only authorized users can easily view them. This setup turns the static site into a pseudo-protected site. It‚Äôs important to note that truly secure content shouldn‚Äôt be published to public servers at all ‚Äì for highly sensitive info, one might maintain it in a private repo or use a hosting service with access control. But for ‚Äúfriends/family‚Äù level privacy, this approach (unlisted pages + Auth0 login on the front-end) is sufficient and commonly used. Auth0‚Äôs documentation and quickstarts will guide the integration of their <span class="caps">SPA</span> <span class="caps">SDK</span> into our static pages, making the process&nbsp;straightforward. </p>
<h2>Tags, Indexes, and Navigation&nbsp;Pages</h2>
<p>We will support <strong>multiple index pages</strong> to help discover content: by tag, by category, by popularity, etc. Pelican automatically creates index pages for <strong>tags and categories</strong>. Each tag will get a page listing all articles with that tag (Pelican‚Äôs templates and generators handle this if enabled). Same for categories (and with our nested scheme, categories like ‚Äúdata_science‚Äù under ‚Äútech/dev‚Äù will show all related posts). We‚Äôll ensure the theme includes pages for tags/categories in the navigation or as part of a&nbsp;sitemap. </p>
<p>For a <strong>‚ÄúMost Read‚Äù</strong> page, since the site is static, we need to gather view statistics from an external source. One option is to use an analytics service (like Google Analytics or Plausible) on the site, then periodically retrieve pageview counts. We can incorporate a <span class="caps">JSON</span> of page view stats (keyed by <span class="caps">URL</span> or slug) and have a build step to sort articles by views and generate a page of ‚ÄúTop 10 most read articles.‚Äù This would be a custom script that runs before site generation to update a data file (or we use Pelican‚Äôs&nbsp;[<code>READERS</code> or data files plugin] to ingest a <span class="caps">CSV</span>/<span class="caps">JSON</span>). Alternatively, if we don‚Äôt have analytics integration, we might define &#8220;most read&#8221; manually or by other metrics (like an editorial choice or proxy like time since posted). But assuming we have <span class="caps">GA</span>, we could use Google Analytics Reporting <span class="caps">API</span> via Python to get the most viewed URLs and then produce a static page listing those (with links and maybe view&nbsp;counts). </p>
<p>We also plan a <strong>handcrafted home page</strong> as mentioned earlier. This will likely be a static page (written in Markdown for convenience) that is set as the landing page. We can curate content here ‚Äì e.g., a welcome message, featured posts in different categories, etc. Because Pelican allows creating arbitrary pages (any file&nbsp;under <code>content/pages/</code> by default) and does not force the blog index to be the root, we can completely customize the homepage. For example, the homepage could even be written as a Jinja template itself if we want dynamic content (Pelican allows creating templates for pages). But simpler, we can hardcode or use shortcodes for pulling in snippets (Pelican plugins exist for including content or defining&nbsp;shortcodes). </p>
<p><strong>Navigation:</strong> The site will have a menu (likely in the header) linking to key index pages: e.g. <em>Blog</em>, <em>Categories</em>, <em>Tags</em>, <em>About</em>, <em>Languages</em>. We will enable&nbsp;Pelican‚Äôs <code>DISPLAY_PAGES_ON_MENU</code> and <code>DISPLAY_CATEGORIES_ON_MENU</code> settings as needed, or manually define a menu in config for finer control. The Ghost-based theme we use might already support a configurable menu. We‚Äôll include a link to the ‚ÄúAll Tags‚Äù page and maybe a link to ‚ÄúAll Posts‚Äù archive. If the site becomes large, we could add a search functionality; Pelican has a plugin for search that works by building a <span class="caps">JSON</span> index used by a <span class="caps">JS</span> script (for example, <strong>Tipue Search</strong> plugin&nbsp;or <code>pelican-search</code> which provides Lunr.js searc (<a href="https://blog.stanleysolutionsnw.com/adding-search-to-my-pelican-blog-site.html#:~:text=Adding%20Search%20to%20my%20Pelican,based%20system">Adding Search to my Pelican Blog Site | Stanley Solutions Blog</a>)„Äë). That would add a small <span class="caps">JS</span> (still lightweight) to enable full-text search on the client side, which is a nice enhancement for a digital garden. (This is optional but worth noting since gardens benefit from&nbsp;search.) </p>
<h2>Build Pipeline <span class="amp">&amp;</span> Link&nbsp;Validation</h2>
<p>To tie everything together, we‚Äôll set up a robust <strong>build pipeline</strong> (e.g., using GitHub Actions or similar <span class="caps">CI</span>) to automate site generation, validation, and deployment to GitHub Pages. The stages would&nbsp;include: </p>
<ol>
<li>
<p><strong>Generate Site:</strong> Use Pelican to build the site. This involves installing the Python dependencies (Pelican and required plugins&nbsp;like <code>pelican-i18n_subsites</code>, <code>pelican-wikilinks</code>, etc., all available via pip), then&nbsp;running <code>pelican content -o output -s pelicanconf.py</code> (and possibly once per language if using i18n plugin in a certain way). The Pelican config will include all our settings (paths, plugins, theme,&nbsp;etc.). </p>
</li>
<li>
<p><strong>Validate Internal Links:</strong> After generation, we perform a link check focusing on internal links. We want to catch any broken references (especially from the wiki links or manual links). We can use an automated link checker ‚Äì for example, a tool like <strong>LinkChecker</strong> (Python)&nbsp;or <code>html-proofer</code>. A Python approach could be writing a small script that parses all output <span class="caps">HTML</span> files and verifies that&nbsp;every <code>&lt;a href&gt;</code> pointing to the same domain has a corresponding file. Since we have the list of output files, we can map URLs to files easily. Another approach is to use Pelican‚Äôs own link mapping: the Wikilinks plugin might warn if a target is missing. If not, our custom backlink plugin could also log missing targets. In any case, the <span class="caps">CI</span> can run a script to ensure no 404s for internal hyperlinks. If a broken link is found, the build should fail, alerting us to fix the reference or add the missing page. This step addresses the requirement of a <strong>build stage validating internal links</strong> ‚Äì essential in a wiki-like garden where content moves and many cross-links&nbsp;exist. </p>
</li>
<li>
<p><strong>Deploy to GitHub Pages:</strong> Once the site passes checks, the pipeline can deploy it. For GitHub Pages, that typically means pushing&nbsp;the <code>output/</code> (static files) to&nbsp;the <code>gh-pages</code> branch or&nbsp;the <code>docs/</code> folder of the repository. We can use a <span class="caps">GH</span> Action for this, or even GitHub Pages‚Äô native static publishing if we keep the output&nbsp;in <code>docs/</code>. The deployment must include all language versions (possibly in subfolders&nbsp;like <code>en/</code> and <code>es/</code> if configured) and all static assets. Since everything is static, deployment is as simple as uploading the files ‚Äì no server-side logic&nbsp;needed. </p>
</li>
<li>
<p><strong>(Optional) Post-deploy Tasks:</strong> If using analytics for ‚Äúmost read‚Äù or if we want to purge a <span class="caps">CDN</span> cache, etc., those could be additional steps. But not strictly necessary for core&nbsp;functionality. </p>
</li>
</ol>
<p><strong>Actively Maintained Tools:</strong> All components in this stack are widely used and maintained. Pelican is a mature project (10k+ stars on GitHub, active as of 2025 (<a href="https://www.reddit.com/r/django/comments/oxuxg1/pelican_for_professional_website/#:~:text=pelican%20for%20professional%20website%20%3A,is%2C%20what%20is%20your">pelican for professional website : r/django - Reddit</a>)„Äë, and its plugins (like Wikilinks and i18n) are actively kept up-to-date with Pelican release (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Further%20configuration%20will%20depend%20on,file">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>)„Äë. Auth0 is a reliable commercial platform with extensive documentation and support for <span class="caps">SPA</span> integration. Any <span class="caps">AI</span> translation step can utilize stable APIs (Google Translate, DeepL) or libraries. By using established tools, we ensure longevity and community&nbsp;support. </p>
<h2>Summary of the Recommended&nbsp;Stack</h2>
<ul>
<li><strong>Pelican (Python Static Site Generator)</strong> ‚Äì Core engine for markdown-to-<span class="caps">HTML</span>, multi-language output, theming, and plugin (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>)„Äë.  </li>
<li><strong>Content Structure:</strong> Markdown files in a nested directory hierarchy, one article per folder with associated images/docs, using Pelican‚Äôs attach mechanism for bundling asset (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=Starting%20with%20Pelican%203,sibling%20of%20the%20linking%20document">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>) (<a href="https://docs.getpelican.com/en/latest/content.html#:~:text=%21%5BIcon%5D%28">Writing content - <span class="caps">PELICAN</span> 4.11.0</a>)„Äë.  </li>
<li><strong>Pelican&nbsp;Plugins:</strong> </li>
<li><em>Wikilinks</em>&nbsp;for <code>[[wiki-style]]</code> link syntax between page (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>)„Äë. </li>
<li><em>i18n_subsites</em> for multi-language site generation (creating language-specific versions of the site (<a href="https://siongui.github.io/2017/01/07/pelican-translate-string-according-to-default-language-in-theme/#:~:text=Pelican%20static%20site%20generator%20and,macro%20to%20achieve%20this%20goal">[Pelican] Translate String According to Default Language in Theme</a>)„Äë. </li>
<li><em>Neighbors</em> (if using a theme that requires it) to get next/previous article links easil (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Abr4xas%2C%20amendments%20by%20Colin%20Wren">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)„Äë. </li>
<li><em>Tipue Search or similar</em> (optional) for client-side search functionalit (<a href="https://blog.stanleysolutionsnw.com/adding-search-to-my-pelican-blog-site.html#:~:text=Adding%20Search%20to%20my%20Pelican,based%20system">Adding Search to my Pelican Blog Site | Stanley Solutions Blog</a>)„Äë. </li>
<li>Custom plugins for backlink aggregation and any additional validation or content processing (<span class="caps">AI</span> translation insertion could also be done here or in <span class="caps">CI</span>). </li>
<li><strong>Templates/Theming:</strong> A responsive theme inspired by Ghost‚Äôs <strong>Casper</strong> (e.g. Casper2Pelica (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Casper2Pelican">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)„Äë or another port) to provide a clean, modern <span class="caps">UI</span>. We will customize templates for special content types (recipes, trips) using Pelican‚Äôs template override featur (<a href="https://docs.getpelican.com/en/4.7.2/content.html#file-metadata#:~:text=match%20at%20L131%20,to%20use%20for%20this%20article%2Fpage">Writing content ‚Äî Pelican 4.7.2 documentation</a>)„Äë and front-matter metadata, and include visual enhancements (cover images, syntax highlighting for code, etc.). The design will emphasize readability and aesthetics, avoiding a technical&nbsp;look. </li>
<li><strong>Authentication:</strong> Auth0 <span class="caps">SPA</span> integration for protected sections. We do this by embedding Auth0‚Äôs <span class="caps">JS</span> and gating logic in pages marked as non-public. Auth0 manages the user accounts and login dialogs (e.g., via Google OAuth or email/password as configured), and the static site just includes the necessary scripts. This adds a slight <span class="caps">JS</span> dependency on those pages, but only for the sake of auth ‚Äì the overall site remains static and&nbsp;content-focused. </li>
<li><strong>Build/Deployment Pipeline:</strong> Use GitHub Actions (or similar <span class="caps">CI</span>) to run the build. The pipeline will run Pelican, run a <strong>link checker</strong> to validate all internal references (preventing broken links in the graph), and then deploy to GitHub Pages. Content translations via <span class="caps">AI</span> can be automated in this pipeline as well, ensuring the latest content is available in all&nbsp;languages. </li>
</ul>
<p>By combining these technologies, we get a <strong>robust, customizable, and beautiful digital garden system</strong> that meets all the listed requirements. All major components are Python-based (Pelican, plugins, build scripts), aligning with the preference for Python tooling. The architecture leverages static site best practices (pre-render everything for speed and simplicit (<a href="https://github.com/getpelican/pelican#:~:text=With%20Pelican%2C%20you%20can%20create,web%20server%20or%20hosting%20service">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>) (<a href="https://github.com/getpelican/pelican#:~:text=,is%20simple%20to%20host%20anywhere">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>)„Äë) while layering on advanced features like backlinks, full-text search, and role-based access that are often missing from simpler static blogs. The result is a personal knowledge garden that is easy to write in (just Markdown in VSCode), easy to maintain (thanks to automation and plugin support), and delightful for readers in terms of appearance and&nbsp;navigation. </p>
<p><strong>References:</strong> The selection of Pelican is supported by its official docs and community plugins, which confirm it can handle multi-language content, Markdown, and is extensibl (<a href="https://github.com/getpelican/pelican#:~:text=,rich%20plugin%20ecosystem%3A%20Pelican%20Plugins">GitHub - getpelican/pelican: Static site generator that supports Markdown and reST syntax. Powered by Python.</a>) (<a href="https://github.com/MinchinWeb/minchin.pelican.plugins.wikilinks/#:~:text=Usage%20Notes">GitHub - minchinweb/minchin.pelican.plugins.wikilinks: Support Wikilinks when generating Pelican sites</a>)„Äë. The Ghost-inspired design is facilitated by existing Pelican themes (e.g., Casper2Pelican) which explicitly aims to bring Ghost‚Äôs default look to Pelica (<a href="https://github.com/abr4xas/Casper2Pelican#:~:text=Casper2Pelican">GitHub - abr4xas/Casper2Pelican: The default personal blogging theme for pelican</a>)„Äë. Auth0 integration for static sites is a known approach (Auth0 provides <span class="caps">SPA</span> SDKs and guides for static site authentication flow (<a href="https://community.auth0.com/t/protecting-static-website-using-auth0-but-using-existing-users/76359#:~:text=Hello,Auth0%20JavaScript%20SDK%20Quickstarts%3A%20Login">Protecting Static Website using Auth0 but using existing users - Auth0 Community</a>)„Äë). All these pieces together form a cohesive stack to realize the envisioned digital&nbsp;garden.</p>
<h1>Follow up&nbsp;questions</h1>
<p>While ponderimg (and soon testing) the suggested solution, some more questions came up to&nbsp;me.</p>
<h2>Changing the&nbsp;structure</h2>
<ul>
<li>How does the system behave when I move an article feom one location of the tree to&nbsp;another?</li>
<li>How does the system behave when I rename an&nbsp;article?</li>
<li>How does the system behave when I delete an&nbsp;article?</li>
<li>How does the system behave when I rename a&nbsp;folder?</li>
<li>How does the system behave when I delete a&nbsp;folder?</li>
</ul>
<h2>Articles or&nbsp;Pages?</h2>
<p>From the <a href="https://docs.getpelican.com/en/latest/content.html">Pelican documentation</a>:</p>
<blockquote>
<p>Pelican considers ‚Äúarticles‚Äù to be chronological content, such as posts on a blog, and thus associated with a date.
The idea behind ‚Äúpages‚Äù is that they are usually not temporal in nature and are used for content that does not change very often (e.g., ‚ÄúAbout‚Äù or ‚ÄúContact‚Äù&nbsp;pages).</p>
</blockquote>
<p>So what should <strong>my</strong> articles be? In my article concept the date is not too important. But maybe the workflow to edit Pelican articles is easier than the one to edit&nbsp;pages?</p>
<h1>Playing&nbsp;around</h1>
<p>So I create a <a href="https://github.com/tillg/playground_pelican">github repo</a> and start playimng&nbsp;around.</p>
  </div>
</div>
      </div>

      <label for="sidebar-checkbox" class="sidebar-toggle"></label>

      <script>
        (function(document) {
          var i = 0;
          // snip empty header rows since markdown can't
          var rows = document.querySelectorAll('tr');
          for(i=0; i<rows.length; i++) {
            var ths = rows[i].querySelectorAll('th');
            var rowlen = rows[i].children.length;
            if (ths.length > 0 && ths.length === rowlen) {
              rows[i].remove();
            }
          }
        })(document);
      </script>

      <script>
        /* Lanyon & Poole are Copyright (c) 2014 Mark Otto. Adapted to Pelican 20141223 and extended a bit by @thomaswilley */
        (function(document) {
          var toggle = document.querySelector('.sidebar-toggle');
          var sidebar = document.querySelector('#sidebar');
          var checkbox = document.querySelector('#sidebar-checkbox');
          document.addEventListener('click', function(e) {
            var target = e.target;
            if(!checkbox.checked ||
            sidebar.contains(target) ||
            (target === checkbox || target === toggle)) return;
            checkbox.checked = false;
            }, false);
            })(document);
      </script>
     </div>
  </body>
</html>